{"version":3,"sources":["ng://ngx-drag-drop/dnd-utils.ts","ng://ngx-drag-drop/dnd-state.ts","ng://ngx-drag-drop/dnd-draggable.directive.ts","ng://ngx-drag-drop/dnd-dropzone.directive.ts","ng://ngx-drag-drop/dnd-handle.directive.ts","ng://ngx-drag-drop/dnd.module.ts"],"names":["DROP_EFFECTS","CUSTOM_MIME_TYPE","JSON_MIME_TYPE","MSIE_MIME_TYPE","mimeTypeIsCustom","mimeType","substr","length","getWellKnownMimeType","event","dataTransfer","types","i","filterEffects","effects","allowed","filter","effect","toLowerCase","indexOf","calculateDragImageOffset","dragImage","dragImageComputedStyle","window","getComputedStyle","paddingTop","parseFloat","paddingLeft","borderTop","borderTopWidth","borderLeft","borderLeftWidth","x","offsetX","y","offsetY","_dndState","isDragging","dropEffect","effectAllowed","type","undefined","endDrag","setDropEffect","getDropEffect","dataTransferEffectAllowed","ctrlKey","altKey","getDndType","isExternalDrag","dndState","DndDragImageRefDirective","parent","elementRef","registerDragImage","Directive","args","selector","DndDraggableDirective","ElementRef","renderer","ngZone","_this","this","dndEffectAllowed","dndDraggingClass","dndDraggingSourceClass","dndDraggableDisabledClass","dndDragImageOffsetFunction","dndStart","EventEmitter","dndDrag","dndEnd","dndMoved","dndCopied","dndLinked","dndCanceled","draggable","isDragStarted","dragEventHandler","onDrag","Object","defineProperty","prototype","value","removeClass","nativeElement","addClass","dndDisableIf","ngAfterViewInit","runOutsideAngular","addEventListener","ngOnDestroy","removeEventListener","onDragStart","dndHandle","_dndUsingHandle","startDrag","dndType","setDragData","data","dataString","JSON","stringify","setData","e","effectsAllowed","dndDraggable","determineDragImage","dndDragImageElementRef","setDragImage","offsetFunction","offset","unregister","listen","emit","stopPropagation","onDragEnd","dropEffectEmitter","setTimeout","registerDragHandle","handle","Renderer2","NgZone","Input","Output","HostBinding","HostListener","DndPlaceholderRefDirective","DndDropzoneDirective","dndAllowExternal","dndHorizontal","dndDragoverClass","dndDropzoneDisabledClass","dndDragover","dndDrop","placeholder","disabled","dragEnterEventHandler","onDragEnter","dragOverEventHandler","onDragOver","dragLeaveEventHandler","onDragLeave","tryGetPlaceholder","removePlaceholderFromDOM","_dndDropzoneActive","newTarget","document","elementFromPoint","clientX","clientY","contains","isDropAllowed","preventDefault","cleanupDragoverState","defaultPrevented","checkAndUpdatePlaceholderPosition","onDrop","getDropData","dragIsExternal","parse","getData","dropIndex","getPlaceholderIndex","isExternal","index","dndDropzone","Array","isArray","Error","dndPlaceholderRef","querySelector","parentNode","removeChild","appendChild","directChild","getDirectChildElement","parentElement","childElement","shouldPositionPlaceholderBeforeElement","element","horizontal","bounds","getBoundingClientRect","left","width","top","height","previousSibling","insertBefore","nextSibling","call","children","ContentChild","DndHandleDirective","onDragEvent","DndModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["import { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DragDropData {\n  data?:any;\n  type?:string;\n}\n\nexport interface DndEvent extends DragEvent {\n  _dndUsingHandle?:boolean;\n  _dndDropzoneActive?:true;\n}\n\nexport type DndDragImageOffsetFunction = ( event:DragEvent, dragImage:Element ) => { x:number, y:number };\n\nexport const DROP_EFFECTS = [ \"move\", \"copy\", \"link\" ] as DropEffect[];\n\nexport const CUSTOM_MIME_TYPE = \"application/x-dnd\";\nexport const JSON_MIME_TYPE = \"application/json\";\nexport const MSIE_MIME_TYPE = \"Text\";\n\nfunction mimeTypeIsCustom( mimeType:string ) {\n\n  return mimeType.substr( 0, CUSTOM_MIME_TYPE.length ) === CUSTOM_MIME_TYPE;\n}\n\nexport function getWellKnownMimeType( event:DragEvent ):string | null {\n\n  if( event.dataTransfer ) {\n\n    const types = event.dataTransfer.types;\n\n    // IE 9 workaround.\n    if( !types ) {\n\n      return MSIE_MIME_TYPE;\n    }\n\n    for( let i = 0; i < types.length; i++ ) {\n\n      if( types[ i ] === MSIE_MIME_TYPE\n        || types[ i ] === JSON_MIME_TYPE\n        || mimeTypeIsCustom( types[ i ] ) ) {\n\n        return types[ i ];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function setDragData( event:DragEvent, data:DragDropData, effectAllowed:EffectAllowed ):void {\n\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  const mimeType = CUSTOM_MIME_TYPE + (data.type ? (\"-\" + data.type) : \"\");\n\n  const dataString = JSON.stringify( data );\n\n  try {\n\n    event.dataTransfer.setData( mimeType, dataString );\n\n  }\n  catch( e ) {\n\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n\n      event.dataTransfer.setData( JSON_MIME_TYPE, dataString );\n\n    }\n    catch( e ) {\n\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n      const effectsAllowed = filterEffects( DROP_EFFECTS, effectAllowed );\n      event.dataTransfer.effectAllowed = effectsAllowed[ 0 ];\n\n      event.dataTransfer.setData( MSIE_MIME_TYPE, dataString );\n    }\n  }\n}\n\nexport function getDropData( event:DragEvent, dragIsExternal:boolean ):DragDropData {\n\n  // check if the mime type is well known\n  const mimeType = getWellKnownMimeType( event );\n\n  // drag did not originate from [dndDraggable]\n  if( dragIsExternal === true ) {\n\n    if( mimeType !== null\n      && mimeTypeIsCustom( mimeType ) ) {\n\n      // the type of content is well known and safe to handle\n      return JSON.parse( event.dataTransfer.getData( mimeType ) );\n    }\n\n    // the contained data is unknown, let user handle it\n    return {};\n  }\n\n  // the type of content is well known and safe to handle\n  return JSON.parse( event.dataTransfer.getData( mimeType ) );\n}\n\nexport function filterEffects( effects:DropEffect[], allowed:EffectAllowed | DropEffect ):DropEffect[] {\n\n  if( allowed === \"all\"\n    || allowed === \"uninitialized\" ) {\n\n    return effects;\n  }\n\n  return effects.filter( function( effect ) {\n\n    return allowed.toLowerCase().indexOf( effect ) !== -1;\n  } );\n}\n\nexport function getDirectChildElement( parentElement:Element, childElement:Element ):Element | null {\n\n  let directChild:Node = childElement;\n\n  while( directChild.parentNode !== parentElement ) {\n\n    // reached root node without finding given parent\n    if( !directChild.parentNode ) {\n\n      return null;\n    }\n\n    directChild = directChild.parentNode;\n  }\n\n  return directChild as Element;\n}\n\nexport function shouldPositionPlaceholderBeforeElement( event:DragEvent, element:Element, horizontal:boolean ) {\n\n  const bounds = element.getBoundingClientRect();\n\n  // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n  if( horizontal ) {\n\n    return (event.clientX < bounds.left + bounds.width / 2);\n  }\n\n  return (event.clientY < bounds.top + bounds.height / 2);\n}\n\nexport function calculateDragImageOffset( event:DragEvent, dragImage:Element ):{ x:number, y:number } {\n\n  const dragImageComputedStyle = window.getComputedStyle( dragImage );\n  const paddingTop = parseFloat( dragImageComputedStyle.paddingTop ) || 0;\n  const paddingLeft = parseFloat( dragImageComputedStyle.paddingLeft ) || 0;\n  const borderTop = parseFloat( dragImageComputedStyle.borderTopWidth ) || 0;\n  const borderLeft = parseFloat( dragImageComputedStyle.borderLeftWidth ) || 0;\n\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\n\nexport function setDragImage( event:DragEvent, dragImage:Element, offsetFunction:DndDragImageOffsetFunction ):void {\n\n  const offset = offsetFunction( event, dragImage ) || {x: 0, y: 0};\n\n  (event.dataTransfer as any).setDragImage( dragImage, offset.x, offset.y );\n}\n","import {\n  CUSTOM_MIME_TYPE,\n  DROP_EFFECTS,\n  filterEffects,\n  getWellKnownMimeType,\n  JSON_MIME_TYPE,\n  MSIE_MIME_TYPE\n} from \"./dnd-utils\";\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DndState {\n  isDragging:boolean;\n  dropEffect?:DropEffect;\n  effectAllowed?:EffectAllowed;\n  type?:string;\n}\n\nconst _dndState:DndState = {\n  isDragging: false,\n  dropEffect: \"none\",\n  effectAllowed: \"all\",\n  type: undefined\n};\n\nexport function startDrag( event:DragEvent, effectAllowed:EffectAllowed, type:string | undefined ) {\n\n  _dndState.isDragging = true;\n  _dndState.dropEffect = \"none\";\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n\n  event.dataTransfer.effectAllowed = effectAllowed;\n}\n\nexport function endDrag() {\n\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\n\nexport function setDropEffect( event:DragEvent, dropEffect:DropEffect ) {\n\n  if( _dndState.isDragging === true ) {\n\n    _dndState.dropEffect = dropEffect;\n  }\n\n  event.dataTransfer.dropEffect = dropEffect;\n}\n\nexport function getDropEffect( event:DragEvent, effectAllowed?:EffectAllowed | DropEffect ):DropEffect {\n\n  const dataTransferEffectAllowed:EffectAllowed = (event.dataTransfer) ? event.dataTransfer.effectAllowed as EffectAllowed : \"uninitialized\";\n\n  let effects = filterEffects( DROP_EFFECTS, dataTransferEffectAllowed );\n\n  if( _dndState.isDragging === true ) {\n\n    effects = filterEffects( effects, _dndState.effectAllowed );\n  }\n\n  if( effectAllowed ) {\n\n    effects = filterEffects( effects, effectAllowed );\n  }\n\n  // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n  if( effects.length === 0 ) {\n\n    return \"none\";\n  }\n\n  if( event.ctrlKey && effects.indexOf( \"copy\" ) !== -1 ) {\n\n    return \"copy\";\n  }\n\n  if( event.altKey && effects.indexOf( \"link\" ) !== -1 ) {\n\n    return \"link\";\n  }\n\n  return effects[ 0 ] as DropEffect;\n}\n\nexport function getDndType( event:DragEvent ):string | undefined {\n\n  if( _dndState.isDragging === true ) {\n\n    return _dndState.type;\n  }\n\n  const mimeType = getWellKnownMimeType( event );\n\n  if( mimeType === null ) {\n\n    return undefined;\n  }\n\n  if( mimeType === MSIE_MIME_TYPE\n    || mimeType === JSON_MIME_TYPE ) {\n\n    return undefined;\n  }\n\n  return mimeType.substr( CUSTOM_MIME_TYPE.length + 1 ) || undefined;\n}\n\nexport function isExternalDrag():boolean {\n\n  return _dndState.isDragging === false;\n}\n\nexport const dndState:Readonly<DndState> = _dndState as Readonly<DndState>;\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostBinding,\n  HostListener,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  Renderer2\n} from \"@angular/core\";\nimport { calculateDragImageOffset, DndDragImageOffsetFunction, DndEvent, setDragData, setDragImage } from \"./dnd-utils\";\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\nimport { dndState, endDrag, startDrag } from \"./dnd-state\";\nimport { EffectAllowed } from \"./dnd-types\";\n\n@Directive( {\n  selector: \"[dndDragImageRef]\"\n} )\nexport class DndDragImageRefDirective {\n\n  constructor( parent:DndDraggableDirective,\n               elementRef:ElementRef ) {\n\n    parent.registerDragImage( elementRef );\n  }\n}\n\n@Directive( {\n  selector: \"[dndDraggable]\"\n} )\nexport class DndDraggableDirective implements AfterViewInit, OnDestroy {\n\n  @Input()\n  dndDraggable:any;\n\n  @Input()\n  dndEffectAllowed:EffectAllowed = \"copy\";\n\n  @Input()\n  dndType?:string;\n\n  @Input()\n  dndDraggingClass = \"dndDragging\";\n\n  @Input()\n  dndDraggingSourceClass = \"dndDraggingSource\";\n\n  @Input()\n  dndDraggableDisabledClass = \"dndDraggableDisabled\";\n\n  @Input()\n  dndDragImageOffsetFunction:DndDragImageOffsetFunction = calculateDragImageOffset;\n\n  @Output()\n  readonly dndStart:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndDrag:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndEnd:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndMoved:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndCopied:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndLinked:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndCanceled:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @HostBinding( \"attr.draggable\" )\n  draggable = true;\n\n  private dndHandle?:DndHandleDirective;\n\n  private dndDragImageElementRef?:ElementRef;\n\n  private dragImage:Element;\n\n  private isDragStarted:boolean = false;\n\n  private readonly dragEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDrag( event );\n\n  @Input()\n  set dndDisableIf( value:boolean ) {\n\n    this.draggable = !value;\n\n    if( this.draggable ) {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n    else {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n  }\n\n  @Input()\n  set dndDisableDragIf( value:boolean ) {\n    this.dndDisableIf = value;\n  }\n\n  constructor( private elementRef:ElementRef,\n               private renderer:Renderer2,\n               private ngZone:NgZone ) {\n  }\n\n  ngAfterViewInit():void {\n    this.ngZone.runOutsideAngular( () => {\n      this.elementRef.nativeElement.addEventListener( \"drag\", this.dragEventHandler );\n    } );\n  }\n\n  ngOnDestroy():void {\n    this.elementRef.nativeElement.removeEventListener( \"drag\", this.dragEventHandler );\n    if(this.isDragStarted === true) {\n      endDrag()\n    }\n  }\n\n  @HostListener( \"dragstart\", [ \"$event\" ] )\n  onDragStart( event:DndEvent ) {\n\n    if( this.draggable === false ) {\n\n      return false;\n    }\n\n    // check if there is dnd handle and if the dnd handle was used to start the drag\n    if( typeof this.dndHandle !== \"undefined\"\n      && typeof event._dndUsingHandle === \"undefined\" ) {\n\n      return false;\n    }\n\n    // initialize global state\n    startDrag( event, this.dndEffectAllowed, this.dndType );\n\n    this.isDragStarted = true;\n\n    setDragData( event, {data: this.dndDraggable, type: this.dndType}, dndState.effectAllowed );\n\n    this.dragImage = this.determineDragImage();\n\n    // set dragging css class prior to setDragImage so styles are applied before\n    // TODO breaking change: add class to elementRef rather than drag image which could be another element\n    this.renderer.addClass( this.dragImage, this.dndDraggingClass );\n\n    // set custom dragimage if present\n    // set dragimage if drag is started from dndHandle\n    if( typeof this.dndDragImageElementRef !== \"undefined\"\n      || typeof event._dndUsingHandle !== \"undefined\" ) {\n\n      setDragImage( event, this.dragImage, this.dndDragImageOffsetFunction );\n    }\n\n    // add dragging source css class on first drag event\n    const unregister = this.renderer.listen( this.elementRef.nativeElement, \"drag\", () => {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n      unregister();\n    } );\n\n    this.dndStart.emit( event );\n\n    event.stopPropagation();\n  }\n\n  onDrag( event:DragEvent ) {\n\n    this.dndDrag.emit( event );\n  }\n\n  @HostListener( \"dragend\", [ \"$event\" ] )\n  onDragEnd( event:DragEvent ) {\n\n    // get drop effect from custom stored state as its not reliable across browsers\n    const dropEffect = dndState.dropEffect;\n\n    let dropEffectEmitter:EventEmitter<DragEvent>;\n\n    switch( dropEffect ) {\n\n      case \"copy\":\n        dropEffectEmitter = this.dndCopied;\n        break;\n\n      case \"link\":\n        dropEffectEmitter = this.dndLinked;\n        break;\n\n      case \"move\":\n        dropEffectEmitter = this.dndMoved;\n        break;\n\n      default:\n        dropEffectEmitter = this.dndCanceled;\n        break;\n    }\n\n    dropEffectEmitter.emit( event );\n    this.dndEnd.emit( event );\n\n    // reset global state\n    endDrag();\n\n    this.isDragStarted = false;\n\n    this.renderer.removeClass( this.dragImage, this.dndDraggingClass );\n\n    // IE9 special hammering\n    window.setTimeout( () => {\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n    }, 0 );\n\n    event.stopPropagation();\n  }\n\n  registerDragHandle( handle:DndHandleDirective | undefined ) {\n\n    this.dndHandle = handle;\n  }\n\n  registerDragImage( elementRef:ElementRef | undefined ) {\n\n    this.dndDragImageElementRef = elementRef;\n  }\n\n  private determineDragImage():Element {\n\n    // evaluate custom drag image existence\n    if( typeof this.dndDragImageElementRef !== \"undefined\" ) {\n\n      return this.dndDragImageElementRef.nativeElement as Element;\n    }\n    else {\n\n      return this.elementRef.nativeElement;\n    }\n  }\n}\n","import {\n  AfterViewInit,\n  ContentChild,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  Renderer2\n} from \"@angular/core\";\nimport {\n  DndEvent,\n  DragDropData,\n  getDirectChildElement,\n  getDropData,\n  shouldPositionPlaceholderBeforeElement\n} from \"./dnd-utils\";\nimport { getDndType, getDropEffect, isExternalDrag, setDropEffect } from \"./dnd-state\";\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DndDropEvent {\n  event:DragEvent;\n  dropEffect:DropEffect;\n  isExternal:boolean;\n  data?:any;\n  index?:number;\n  type?:any;\n}\n\n@Directive( {\n  selector: \"[dndPlaceholderRef]\"\n} )\nexport class DndPlaceholderRefDirective {\n\n  constructor( public readonly elementRef:ElementRef ) {\n  }\n}\n\n@Directive( {\n  selector: \"[dndDropzone]\"\n} )\nexport class DndDropzoneDirective implements AfterViewInit, OnDestroy {\n\n  @Input()\n  dndDropzone?:string[];\n\n  @Input()\n  dndEffectAllowed:EffectAllowed;\n\n  @Input()\n  dndAllowExternal:boolean = false;\n\n  @Input()\n  dndHorizontal:boolean = false;\n\n  @Input()\n  dndDragoverClass:string = \"dndDragover\";\n\n  @Input()\n  dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n\n  @Output()\n  readonly dndDragover:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndDrop:EventEmitter<DndDropEvent> = new EventEmitter<DndDropEvent>();\n\n  @ContentChild( DndPlaceholderRefDirective )\n  private readonly dndPlaceholderRef?:DndPlaceholderRefDirective;\n\n  private placeholder:Element | null = null;\n\n  private disabled:boolean = false;\n\n  private readonly dragEnterEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragEnter( event );\n  private readonly dragOverEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragOver( event );\n  private readonly dragLeaveEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragLeave( event );\n\n  @Input()\n  set dndDisableIf( value:boolean ) {\n\n    this.disabled = !!value;\n\n    if( this.disabled ) {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n    else {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n  }\n\n  @Input()\n  set dndDisableDropIf( value:boolean ) {\n    this.dndDisableIf = value;\n  }\n\n  constructor( private ngZone:NgZone,\n               private elementRef:ElementRef,\n               private renderer:Renderer2 ) {\n  }\n\n  ngAfterViewInit():void {\n\n    this.placeholder = this.tryGetPlaceholder();\n\n    this.removePlaceholderFromDOM();\n\n    this.ngZone.runOutsideAngular( () => {\n      this.elementRef.nativeElement.addEventListener( \"dragenter\", this.dragEnterEventHandler );\n      this.elementRef.nativeElement.addEventListener( \"dragover\", this.dragOverEventHandler );\n      this.elementRef.nativeElement.addEventListener( \"dragleave\", this.dragLeaveEventHandler );\n    } );\n  }\n\n  ngOnDestroy():void {\n    this.elementRef.nativeElement.removeEventListener( \"dragenter\", this.dragEnterEventHandler );\n    this.elementRef.nativeElement.removeEventListener( \"dragover\", this.dragOverEventHandler );\n    this.elementRef.nativeElement.removeEventListener( \"dragleave\", this.dragLeaveEventHandler );\n  }\n\n  onDragEnter( event:DndEvent ) {\n\n    // check if another dropzone is activated\n    if( event._dndDropzoneActive === true ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // set as active if the target element is inside this dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n      }\n    }\n\n    // check if this drag event is allowed to drop on this dropzone\n    const type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    // allow the dragenter\n    event.preventDefault();\n  }\n\n  onDragOver( event:DragEvent ) {\n    // With nested dropzones, we want to ignore this event if a child dropzone\n    // has already handled a dragover.  Historically, event.stopPropagation() was\n    // used to prevent this bubbling, but that prevents any dragovers outside the\n    // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n    // Instead, we can check if the event was already prevented by a child and bail early.\n    if( event.defaultPrevented ) {\n\n      return;\n    }\n\n    // check if this drag event is allowed to drop on this dropzone\n    const type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    this.checkAndUpdatePlaceholderPosition( event );\n\n    const dropEffect = getDropEffect( event, this.dndEffectAllowed );\n\n    if( dropEffect === \"none\" ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // allow the dragover\n    event.preventDefault();\n\n    // set the drop effect\n    setDropEffect( event, dropEffect );\n\n    this.dndDragover.emit( event );\n\n    this.renderer.addClass( this.elementRef.nativeElement, this.dndDragoverClass );\n  }\n\n  @HostListener( \"drop\", [ \"$event\" ] )\n  onDrop( event:DragEvent ) {\n\n    try {\n\n      // check if this drag event is allowed to drop on this dropzone\n      const type = getDndType( event );\n      if( this.isDropAllowed( type ) === false ) {\n\n        return;\n      }\n\n      const data:DragDropData = getDropData( event, isExternalDrag() );\n\n      if( this.isDropAllowed( data.type ) === false ) {\n\n        return;\n      }\n\n      // signal custom drop handling\n      event.preventDefault();\n\n      const dropEffect = getDropEffect( event );\n\n      setDropEffect( event, dropEffect );\n\n      if( dropEffect === \"none\" ) {\n\n        return;\n      }\n\n      const dropIndex = this.getPlaceholderIndex();\n\n      // if for whatever reason the placeholder is not present in the DOM but it should be there\n      // we don't allow/emit the drop event since it breaks the contract\n      // seems to only happen if drag and drop is executed faster than the DOM updates\n      if( dropIndex === -1 ) {\n\n        return;\n      }\n\n      this.dndDrop.emit( {\n        event: event,\n        dropEffect: dropEffect,\n        isExternal: isExternalDrag(),\n        data: data.data,\n        index: dropIndex,\n        type: type,\n      } );\n\n      event.stopPropagation();\n\n    }\n    finally {\n\n      this.cleanupDragoverState();\n    }\n  }\n\n  onDragLeave( event:DndEvent ) {\n\n    // check if still inside this dropzone and not yet handled by another dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n        return;\n      }\n    }\n\n    this.cleanupDragoverState();\n\n    // cleanup drop effect when leaving dropzone\n    setDropEffect( event, \"none\" );\n  }\n\n  private isDropAllowed( type?:string ):boolean {\n\n    // dropzone is disabled -> deny it\n    if( this.disabled === true ) {\n\n      return false;\n    }\n\n    // if drag did not start from our directive\n    // and external drag sources are not allowed -> deny it\n    if( isExternalDrag() === true\n      && this.dndAllowExternal === false ) {\n\n      return false;\n    }\n\n    // no filtering by types -> allow it\n    if( !this.dndDropzone ) {\n\n      return true;\n    }\n\n    // no type set -> allow it\n    if( !type ) {\n\n      return true;\n    }\n\n    if( Array.isArray( this.dndDropzone ) === false ) {\n\n      throw new Error( \"dndDropzone: bound value to [dndDropzone] must be an array!\" );\n    }\n\n    // if dropzone contains type -> allow it\n    return this.dndDropzone.indexOf( type ) !== -1;\n  }\n\n  private tryGetPlaceholder():Element | null {\n\n    if( typeof this.dndPlaceholderRef !== \"undefined\" ) {\n\n      return this.dndPlaceholderRef.elementRef.nativeElement as Element;\n    }\n\n    // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n    // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n    return this.elementRef.nativeElement.querySelector( \"[dndPlaceholderRef]\" );\n  }\n\n  private removePlaceholderFromDOM() {\n\n    if( this.placeholder !== null\n      && this.placeholder.parentNode !== null ) {\n      this.placeholder.parentNode.removeChild( this.placeholder );\n    }\n  }\n\n  private checkAndUpdatePlaceholderPosition( event:DragEvent ):void {\n\n    if( this.placeholder === null ) {\n\n      return;\n    }\n\n    // make sure the placeholder is in the DOM\n    if( this.placeholder.parentNode !== this.elementRef.nativeElement ) {\n\n      this.renderer.appendChild( this.elementRef.nativeElement, this.placeholder );\n    }\n\n    // update the position if the event originates from a child element of the dropzone\n    const directChild = getDirectChildElement( this.elementRef.nativeElement, event.target as Element );\n\n    // early exit if no direct child or direct child is placeholder\n    if( directChild === null\n      || directChild === this.placeholder ) {\n\n      return;\n    }\n\n    const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement( event, directChild, this.dndHorizontal );\n\n    if( positionPlaceholderBeforeDirectChild ) {\n\n      // do insert before only if necessary\n      if( directChild.previousSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild );\n      }\n    }\n    else {\n\n      // do insert after only if necessary\n      if( directChild.nextSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild.nextSibling );\n      }\n    }\n  }\n\n  private getPlaceholderIndex():number | undefined {\n\n    if( this.placeholder === null ) {\n\n      return undefined;\n    }\n\n    const element = this.elementRef.nativeElement as HTMLElement;\n\n    return Array.prototype.indexOf.call( element.children, this.placeholder );\n  }\n\n  private cleanupDragoverState() {\n\n    this.renderer.removeClass( this.elementRef.nativeElement, this.dndDragoverClass );\n\n    this.removePlaceholderFromDOM();\n  }\n}\n","import { Directive, HostBinding, HostListener } from \"@angular/core\";\nimport { DndEvent } from \"./dnd-utils\";\nimport { DndDraggableDirective } from \"./dnd-draggable.directive\";\n\n@Directive( {\n  selector: \"[dndHandle]\"\n} )\nexport class DndHandleDirective {\n\n  @HostBinding( \"attr.draggable\" )\n  draggable = true;\n\n  constructor( parent:DndDraggableDirective ) {\n\n    parent.registerDragHandle( this );\n  }\n\n  @HostListener( \"dragstart\", [ \"$event\" ] )\n  @HostListener( \"dragend\", [ \"$event\" ] )\n  onDragEvent( event:DndEvent ) {\n\n    event._dndUsingHandle = true;\n  }\n}\n","import { NgModule } from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { DndDraggableDirective, DndDragImageRefDirective } from \"./dnd-draggable.directive\";\nimport { DndDropzoneDirective, DndPlaceholderRefDirective } from \"./dnd-dropzone.directive\";\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\n\n@NgModule( {\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ],\n  exports: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ]\n} )\nexport class DndModule {\n}\n"]}