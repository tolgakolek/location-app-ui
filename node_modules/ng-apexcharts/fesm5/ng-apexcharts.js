import { __spread } from 'tslib';
import { Component, Input, ViewChild, NgModule } from '@angular/core';
import { asapScheduler } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ChartComponent = /** @class */ (function () {
    function ChartComponent() {
        this.autoUpdateSeries = true;
    }
    /**
     * @return {?}
     */
    ChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        asapScheduler.schedule((/**
         * @return {?}
         */
        function () {
            _this.createElement();
        }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ChartComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        asapScheduler.schedule((/**
         * @return {?}
         */
        function () {
            if (_this.autoUpdateSeries && Object.keys(changes).filter((/**
             * @param {?} c
             * @return {?}
             */
            function (c) { return c !== 'series'; })).length === 0) {
                _this.updateSeries(_this.series, true);
                return;
            }
            _this.createElement();
        }));
    };
    /**
     * @private
     * @return {?}
     */
    ChartComponent.prototype.createElement = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var options = {};
        if (this.annotations) {
            options.annotations = this.annotations;
        }
        if (this.chart) {
            options.chart = this.chart;
        }
        if (this.colors) {
            options.colors = this.colors;
        }
        if (this.dataLabels) {
            options.dataLabels = this.dataLabels;
        }
        if (this.series) {
            options.series = this.series;
        }
        if (this.stroke) {
            options.stroke = this.stroke;
        }
        if (this.labels) {
            options.labels = this.labels;
        }
        if (this.legend) {
            options.legend = this.legend;
        }
        if (this.fill) {
            options.fill = this.fill;
        }
        if (this.tooltip) {
            options.tooltip = this.tooltip;
        }
        if (this.plotOptions) {
            options.plotOptions = this.plotOptions;
        }
        if (this.responsive) {
            options.responsive = this.responsive;
        }
        if (this.markers) {
            options.markers = this.markers;
        }
        if (this.noData) {
            options.noData = this.noData;
        }
        if (this.xaxis) {
            options.xaxis = this.xaxis;
        }
        if (this.yaxis) {
            options.yaxis = this.yaxis;
        }
        if (this.grid) {
            options.grid = this.grid;
        }
        if (this.states) {
            options.states = this.states;
        }
        if (this.title) {
            options.title = this.title;
        }
        if (this.subtitle) {
            options.subtitle = this.subtitle;
        }
        if (this.theme) {
            options.theme = this.theme;
        }
        if (this.chartObj) {
            this.chartObj.destroy();
        }
        this.chartObj = new ApexCharts(this.chartElement.nativeElement, options);
        this.render();
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.render = /**
     * @return {?}
     */
    function () {
        return this.chartObj.render();
    };
    /**
     * @param {?} options
     * @param {?} redrawPaths
     * @param {?} animate
     * @return {?}
     */
    ChartComponent.prototype.updateOptions = /**
     * @param {?} options
     * @param {?} redrawPaths
     * @param {?} animate
     * @return {?}
     */
    function (options, redrawPaths, animate) {
        return this.chartObj.updateOptions(options, redrawPaths, animate);
    };
    /**
     * @param {?} newSeries
     * @param {?} animate
     * @return {?}
     */
    ChartComponent.prototype.updateSeries = /**
     * @param {?} newSeries
     * @param {?} animate
     * @return {?}
     */
    function (newSeries, animate) {
        this.chartObj.updateSeries(newSeries, animate);
    };
    /**
     * @param {?} newSeries
     * @param {?=} animate
     * @return {?}
     */
    ChartComponent.prototype.appendSeries = /**
     * @param {?} newSeries
     * @param {?=} animate
     * @return {?}
     */
    function (newSeries, animate) {
        this.chartObj.appendSeries(newSeries, animate);
    };
    /**
     * @param {?} seriesName
     * @return {?}
     */
    ChartComponent.prototype.toggleSeries = /**
     * @param {?} seriesName
     * @return {?}
     */
    function (seriesName) {
        this.chartObj.toggleSeries(seriesName);
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.resetSeries = /**
     * @return {?}
     */
    function () {
        this.chartObj.resetSeries();
    };
    /**
     * @param {?} seriesIndex
     * @param {?=} dataPointIndex
     * @return {?}
     */
    ChartComponent.prototype.toggleDataPointSelection = /**
     * @param {?} seriesIndex
     * @param {?=} dataPointIndex
     * @return {?}
     */
    function (seriesIndex, dataPointIndex) {
        this.chartObj.toggleDataPointSelection(seriesIndex, dataPointIndex);
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.chartObj.destroy();
    };
    /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    ChartComponent.prototype.addXaxisAnnotation = /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    function (options, pushToMemory, context) {
        this.chartObj.addXaxisAnnotation(options, pushToMemory, context);
    };
    /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    ChartComponent.prototype.addYaxisAnnotation = /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    function (options, pushToMemory, context) {
        this.chartObj.addYaxisAnnotation(options, pushToMemory, context);
    };
    /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    ChartComponent.prototype.addPointAnnotation = /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    function (options, pushToMemory, context) {
        this.chartObj.addPointAnnotation(options, pushToMemory, context);
    };
    /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    ChartComponent.prototype.addText = /**
     * @param {?} options
     * @param {?=} pushToMemory
     * @param {?=} context
     * @return {?}
     */
    function (options, pushToMemory, context) {
        this.chartObj.addText(options, pushToMemory, context);
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.dataURI = /**
     * @return {?}
     */
    function () {
        return this.chartObj.dataURI();
    };
    ChartComponent.decorators = [
        { type: Component, args: [{
                    selector: 'apx-chart',
                    template: "<div #chart></div>\n",
                    styles: [""]
                }] }
    ];
    ChartComponent.propDecorators = {
        chart: [{ type: Input }],
        annotations: [{ type: Input }],
        colors: [{ type: Input }],
        dataLabels: [{ type: Input }],
        series: [{ type: Input }],
        stroke: [{ type: Input }],
        labels: [{ type: Input }],
        legend: [{ type: Input }],
        markers: [{ type: Input }],
        noData: [{ type: Input }],
        fill: [{ type: Input }],
        tooltip: [{ type: Input }],
        plotOptions: [{ type: Input }],
        responsive: [{ type: Input }],
        xaxis: [{ type: Input }],
        yaxis: [{ type: Input }],
        grid: [{ type: Input }],
        states: [{ type: Input }],
        title: [{ type: Input }],
        subtitle: [{ type: Input }],
        theme: [{ type: Input }],
        autoUpdateSeries: [{ type: Input }],
        chartElement: [{ type: ViewChild, args: ['chart',] }]
    };
    return ChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var declerations = [
    ChartComponent
];
var NgApexchartsModule = /** @class */ (function () {
    function NgApexchartsModule() {
    }
    NgApexchartsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: __spread(declerations),
                    imports: [],
                    exports: __spread(declerations)
                },] }
    ];
    return NgApexchartsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ChartComponent, NgApexchartsModule };
//# sourceMappingURL=ng-apexcharts.js.map
